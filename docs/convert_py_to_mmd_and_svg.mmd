flowchart TD
start([Start])
n1[function clean_label()]
start --> n1
n2["""    Remove ou substitui caracteres especiais para compatibilidade com Mermaid.    """]
n1 --> n2
n3[label = re.sub('[{}\\"\\\\\\[\\]<>]', '', label)]
n2 --> n3
n4[label = re.sub('\\s+', ' ', label)]
n3 --> n4
n6[function extract_mermaid_from_python_code()]
start --> n6
n7["""    Gera um fluxograma Mermaid simples a partir de um código Python.    """]
n6 --> n7
n8[tree = ast.parse(code_str)]
n7 --> n8
n9[mermaid = ['graph TD']]
n8 --> n9
n10[node_counter = 0]
n9 --> n10
n11[function new_node()]
start --> n11
n12[label = clean_label(label)]
n11 --> n12
n13[node_id = f'N{node_counter}']
n12 --> n13
n14[mermaid.append(f'{node_id}["{label}"]')]
n13 --> n14
n16[function walk()]
start --> n16
n17{if (isinstance(node, ast.FunctionDef))}
n16 --> n17
n18[curr = new_node(f'Func: {node.name}()')]
n17 --> n18
n19{if (parent)}
n18 --> n19
n20[mermaid.append(f'{parent} --> {curr}')]
n19 --> n20
n21((for (node.body)))
n20 --> n21
n22[walk(stmt, curr)]
n21 --> n22
n23{else}
n21 --> n23
n24{if (isinstance(node, ast.If))}
n23 --> n24
n25[cond = new_node(f'If: {astor.to_source(node.test).strip()}')]
n24 --> n25
n26{if (parent)}
n25 --> n26
n27[mermaid.append(f'{parent} --> {cond}')]
n26 --> n27
n28((for (node.body)))
n27 --> n28
n29[walk(stmt, cond)]
n28 --> n29
n30((for (node.orelse)))
n29 --> n30
n31[walk(stmt, cond)]
n30 --> n31
n32{else}
n30 --> n32
n33{if (isinstance(node, ast.For))}
n32 --> n33
n34[target = astor.to_source(node.target).strip()]
n33 --> n34
n35[it = astor.to_source(node.iter).strip()]
n34 --> n35
n36[loop = new_node(f'For: {target} in {it}')]
n35 --> n36
n37{if (parent)}
n36 --> n37
n38[mermaid.append(f'{parent} --> {loop}')]
n37 --> n38
n39((for (node.body)))
n38 --> n39
n40[walk(stmt, loop)]
n39 --> n40
n41{else}
n39 --> n41
n42{if (isinstance(node, ast.While))}
n41 --> n42
n43[test = astor.to_source(node.test).strip()]
n42 --> n43
n44[loop = new_node(f'While: {test}')]
n43 --> n44
n45{if (parent)}
n44 --> n45
n46[mermaid.append(f'{parent} --> {loop}')]
n45 --> n46
n47((for (node.body)))
n46 --> n47
n48[walk(stmt, loop)]
n47 --> n48
n49{else}
n47 --> n49
n50{if (isinstance(node, ast.Expr))}
n49 --> n50
n51[label = astor.to_source(node).strip()]
n50 --> n51
n52[expr = new_node(label)]
n51 --> n52
n53{if (parent)}
n52 --> n53
n54[mermaid.append(f'{parent} --> {expr}')]
n53 --> n54
n55{else}
n53 --> n55
n56{if (isinstance(node, ast.Assign))}
n55 --> n56
n57[label = astor.to_source(node).strip()]
n56 --> n57
n58[assign = new_node(label)]
n57 --> n58
n59{if (parent)}
n58 --> n59
n60[mermaid.append(f'{parent} --> {assign}')]
n59 --> n60
n62((for (tree.body)))
n60 --> n62
n63[walk(n)]
n62 --> n63
n65[function process_all_py_files()]
start --> n65
n66["""    Busca todos os arquivos .py a partir da raiz e gera um .mmd e .svg para cada um.    """]
n65 --> n66
n67((for (os.walk('.'))))
n66 --> n67
n68((for (filenames)))
n67 --> n68
n69{if (filename.endswith('.py'))}
n68 --> n69
n70[full_path = os.path.join(dirpath, filename)]
n69 --> n70
n71[base_name = os.path.splitext(filename)[0]]
n70 --> n71
n72[mmd_path = os.path.join(dirpath, f'{base_name}.mmd')]
n71 --> n72
n73[svg_path = os.path.join(dirpath, f'{base_name}.svg')]
n72 --> n73
n74[print(f'✔️ {mmd_path} gerado.')]
n73 --> n74
n76{if ((__name__ == '__main__'))}
n74 --> n76
n77[process_all_py_files()]
n76 --> n77